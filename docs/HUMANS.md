# HUMANS

The code in this repo is primarily generated by AI agents. 


# Step 1 -- Blueprint
The first step in the process was to have AIs create proposed architectural documents. I ended up asking GPT-5 Pro Claude, Sonnet 4.5, and Gemini Pro 2.5 on all in deep research mode to propose an architectural document. The final solution that I selected was the following: https://g.co/gemini/share/ef5097947855

The prompt was originally dictated using Wispr in a somewhat rambling style, but no effort was made to clean up the prompt after I dictated it. This is typically the style I use for most prompting. After I dictated the prompt once, I would just copy and paste it to the two other platforms I needed to test. 

# Step 2 -- Devops for God
The second step involved me creating a repo with features that could be convenient for an AI agent to operate in, whether it's working locally or, in the case of Codex or Devin, working in the cloud. The idea was to create a test script that properly invoked `firebase emulator:exec` so that it could create a transient database that would be torn down after the tests were run so there's always a clean state and also to introduce a test harness that also could use a special HTTP request to delete the database. I also set up minimal GitHub workflows and documentation.

# Step 3 -- Let 'er Rip
I created an AGENTS.md file and then gave it a go on multiple platforms. I gave Claude, Codex, and Jules each opportunity to implement Phase I of the roadmap. Actually, Codex had two chances because they have a button that makes it easy to launch multiple attempts. All of them created PRs, which you can look through. Ultimately, I spent the most time with Claude's PR. All of them ended up using lots of mocking in the unit test, so they sort of seem like pointless unit tests. So I had Claude actually use the Firestore emulator with live objects. Then I realized that my original prompt was a little ambiguous, and the way Claude chose to support async was a little convoluted. It basically didn't realize that it should be using the async native Firestore client. So, I had it resolve that. This should be visible in the various commits that are part of that PR. Then I asked to do a phase one analysis to see what's the difference between what was actually created versus what was in the phase one objectives. Finally, I had it tweak the architecture document to be clear about how to implement async and sync code and also to prefer live emulation vs. mocking whenever possible. Then, just kind of flesh out more of the details of what the architecture looks like at this point and what the current status of the project is.   Finally I asked it to create a Jupyter notebook that shows how the functionality in Phase I works. 

